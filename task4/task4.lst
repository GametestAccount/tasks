     1                                  ; https://syscalls.mebeim.net/?table=x86/64/x64/v6.5
     2                                  
     3                                  global _start
     4                                  
     5                                  section .data
     6 00000000 456E7465722031206E-         first_num_msg db "Enter 1 number: "
     6 00000009 756D6265723A20     
     7                                      LEN_1 equ $ - first_num_msg
     8                                  
     9 00000010 456E7465722032206E-         second_num_msg db "Enter 2 number: "
     9 00000019 756D6265723A20     
    10                                      LEN_2 equ $ - second_num_msg
    11                                  
    12 00000020 416E737765723A20            answer_msg db "Answer: "
    13                                      LEN_3 equ $ - answer_msg
    14                                  
    15                                  section .bss
    16 00000000 <res 40h>                   buffer resb 64             ; зарезервировать 64 байта
    17                                  
    18                                  section .text
    19                                  _start:
    20 00000000 B801000000                  mov rax, 1                 ; write()
    21 00000005 BF01000000                  mov rdi, 1                 ; передаём дескриптор stdout
    22 0000000A 48BE-                       mov rsi, first_num_msg     ; передаём сообщение на вывод
    22 0000000C [0000000000000000] 
    23 00000014 BA10000000                  mov rdx, LEN_1             ; передаём размер сообщения в байтах
    24 00000019 0F05                        syscall
    25 0000001B 4883F8FF                    cmp rax, -1                ; проверить возвращаемое значение
    26 0000001F 0F8416010000                je .exit_failure           ; если там -1, то аварийно завершаем программу
    27                                  
    28 00000025 B800000000                  mov rax, 0                 ; read()
    29 0000002A BF00000000                  mov rdi, 0                 ; передаём дескриптор stdin
    30 0000002F 48BE-                       mov rsi, buffer            ; передаём буфер, куда будут считываться данные
    30 00000031 [0000000000000000] 
    31 00000039 BA40000000                  mov rdx, 64                ; передаём размер буфера в байтах
    32 0000003E 0F05                        syscall
    33 00000040 4883F8FF                    cmp rax, -1                ; проверить возвращаемое значение
    34 00000044 0F84F1000000                je .exit_failure           ; если там -1, то аварийно завершаем программу
    35                                  
    36 0000004A 48FFC8                      dec rax                    ; не учитываем '\n' в конце
    37                                  
    38 0000004D 48BF-                       mov rdi, buffer            ; передаём указатель на буфер
    38 0000004F [0000000000000000] 
    39 00000057 4889C6                      mov rsi, rax               ; передаём количество считанных данных
    40 0000005A E8EF000000                  call func_stoi
    41 0000005F 4989C4                      mov r12, rax               ; сохраним возвращаемое значение в r12
    42                                  
    43 00000062 B801000000                  mov rax, 1                 ; write()
    44 00000067 BF01000000                  mov rdi, 1                 ; передаём дескриптор stdout
    45 0000006C 48BE-                       mov rsi, second_num_msg    ; передаём сообщение на вывод
    45 0000006E [1000000000000000] 
    46 00000076 BA10000000                  mov rdx, LEN_2             ; передаём размер сообщения в байтах
    47 0000007B 0F05                        syscall
    48 0000007D 4883F8FF                    cmp rax, -1                ; проверить возвращаемое значение
    49 00000081 0F84B4000000                je .exit_failure           ; если там -1, то аварийно завершаем программу
    50                                  
    51 00000087 B800000000                  mov rax, 0                 ; read()
    52 0000008C BF00000000                  mov rdi, 0                 ; передаём дескриптор stdin
    53 00000091 48BE-                       mov rsi, buffer            ; передаём буфер, куда буду считываться данные
    53 00000093 [0000000000000000] 
    54 0000009B BA40000000                  mov rdx, 64                ; передаём размер буфера в байтах
    55 000000A0 0F05                        syscall
    56 000000A2 4883F8FF                    cmp rax, -1                ; проверить возвращаемое значение
    57 000000A6 0F848F000000                je .exit_failure           ; если там -1, то аварийно завершаем программу
    58                                  
    59 000000AC 48FFC8                      dec rax                    ; не учитываем '\n' в конце
    60                                  
    61 000000AF 48BF-                       mov rdi, buffer            ; передаём указатель на буфер
    61 000000B1 [0000000000000000] 
    62 000000B9 4889C6                      mov rsi, rax               ; передаём количество считанных данных
    63 000000BC E88D000000                  call func_stoi
    64 000000C1 4989C5                      mov r13, rax               ; сохраним возвращаемое значение в r13
    65                                  
    66 000000C4 4C89E7                      mov rdi, r12               ; передаём первое слагаемое
    67 000000C7 4C89EE                      mov rsi, r13               ; передаём второе слагаемое
    68 000000CA E878000000                  call func_sum
    69                                  
    70 000000CF 4889C7                      mov rdi, rax               ; передаём сумму (число)
    71 000000D2 48BE-                       mov rsi, buffer            ; передаём указатель на буфер
    71 000000D4 [0000000000000000] 
    72 000000DC E8A1000000                  call func_itos
    73 000000E1 4989C6                      mov r14, rax               ; сохраняем в r14 количество записанных символов в буфере
    74                                  
    75 000000E4 41C686[00000000]0A          mov byte[buffer + r14], 10 ; добавим \n в конец буфера
    76 000000EC 49FFC6                      inc r14                    ; инкрементируем кол-во символов в буфере
    77                                  
    78 000000EF B801000000                  mov rax, 1                 ; write()
    79 000000F4 BF01000000                  mov rdi, 1                 ; передаём дескриптор stdout
    80 000000F9 48BE-                       mov rsi, answer_msg        ; передаём сообщение на вывод
    80 000000FB [2000000000000000] 
    81 00000103 BA08000000                  mov rdx, LEN_3             ; передаём размер сообщения в байтах
    82 00000108 0F05                        syscall
    83 0000010A 4883F8FF                    cmp rax, -1                ; проверить возвращаемое значение
    84 0000010E 742B                        je .exit_failure           ; если там -1, то аварийно завершаем программу
    85                                  
    86 00000110 B801000000                  mov rax, 1                 ; write()
    87 00000115 BF01000000                  mov rdi, 1                 ; передаём дескриптор stdout
    88 0000011A 48BE-                       mov rsi, buffer            ; передаём буфер с сообщением на вывод
    88 0000011C [0000000000000000] 
    89 00000124 4C89F2                      mov rdx, r14               ; передаём размер сообщения в байтах
    90 00000127 0F05                        syscall
    91 00000129 4883F8FF                    cmp rax, -1                ; проверить возвращаемое значение
    92 0000012D 740C                        je .exit_failure           ; если там -1, то аварийно завершаем программу
    93                                  
    94 0000012F B83C000000                  mov rax, 60                ; exit()
    95 00000134 BF00000000                  mov rdi, 0                 ; передаём EXIT_SUCCESS
    96 00000139 0F05                        syscall
    97                                  
    98                                  .exit_failure:
    99 0000013B B83C000000                  mov rax, 60                ; exit()
   100 00000140 BF01000000                  mov rdi, 1                 ; передаём EXIT_FAILURE
   101 00000145 0F05                        syscall
   102                                  
   103                                  ; Функция вычисление суммы двух чисел
   104                                  ; Аргументы:
   105                                  ;   A - первое слагаемое;
   106                                  ;   B - второе слагаемое.
   107                                  ; Возвращаемое значение: сумма чисел
   108                                  func_sum:
   109 00000147 4801F7                      add rdi, rsi               ; A + B
   110 0000014A 4889F8                      mov rax, rdi               ; вернуть результат из функции
   111 0000014D C3                          ret
   112                                  
   113                                  ; Функция преобразования строки в число
   114                                  ; Аргументы:
   115                                  ;   buf - указатель на буфер с числом;
   116                                  ;   BUF_LEN - количество байт в буфере.
   117                                  ; Возвращаемое значение: преобразованное число
   118                                  func_stoi:
   119 0000014E 41B800000000                mov r8, 0                  ; sum = 0
   120 00000154 41B901000000                mov r9, 1                  ; mult = 1
   121 0000015A 4C8D1437                    lea r10, [rdi + rsi]       ; rbuf = &buf[BUF_LEN]
   122                                  
   123                                  .loop:
   124                                      ; rbuf -= 1
   125 0000015E 49FFCA                      dec r10
   126                                  
   127                                      ; digit = *rbuf - '0'
   128 00000161 41BB00000000                mov r11, 0
   129 00000167 458A1A                      mov r11b, [r10]
   130 0000016A 4983EB30                    sub r11, '0'
   131                                  
   132                                      ; sum += digit * mult
   133 0000016E 4D0FAFD9                    imul r11, r9
   134 00000172 4D01D8                      add r8, r11
   135                                  
   136                                      ; mult *= 10
   137 00000175 4D6BC90A                    imul r9, 10
   138                                  
   139 00000179 4C39D7                      cmp rdi, r10
   140 0000017C 72E0                        jb .loop                   ; если buf < rbuf то переходим в начало
   141                                  
   142 0000017E 4C89C0                      mov rax, r8                ; вернуть результат из функции
   143 00000181 C3                          ret
   144                                  
   145                                  ; Функция преобразования числа в строку
   146                                  ; Аргументы:
   147                                  ;   m - число
   148                                  ;   buf - указатель на буфер с числом;
   149                                  ; Возвращаемое значение: количество байт, записанных в буфер
   150                                  func_itos:
   151 00000182 41B80A000000                mov r8, 10                 ; b = 10
   152 00000188 41B900000000                mov r9, 0                  ; i = 0
   153                                  
   154                                  .loop:
   155 0000018E 4889F8                      mov rax, rdi
   156 00000191 4899                        cqo                        ; расширяем RDX знаковым битом из RAX
   157 00000193 49F7F0                      div r8
   158                                  
   159 00000196 4883C230                    add rdx, '0'               ; прибавляем к остатку '0'
   160                                  
   161 0000019A 4288140E                    mov [rsi + r9], dl         ; buf[i] = m % 10
   162                                  
   163 0000019E 4889C7                      mov rdi, rax               ; m /= 10
   164 000001A1 49FFC1                      inc r9                     ; i += 1
   165 000001A4 4883FF00                    cmp rdi, 0
   166 000001A8 75E4                        jnz .loop                  ; если m != 0, то возвращаемся в начало
   167                                  
   168 000001AA 4889F7                      mov rdi, rsi               ; передать указатель на буфер
   169 000001AD 4C89CE                      mov rsi, r9                ; передать размер данных в буфере
   170 000001B0 E804000000                  call func_reverse
   171                                  
   172 000001B5 4C89C8                      mov rax, r9                ; вернуть результат из функции
   173 000001B8 C3                          ret
   174                                  
   175                                  ; Функция переворота массива
   176                                  ; Аргументы:
   177                                  ;   buf - указатель на буфер;
   178                                  ;   BUF_LEN - количество байт в буфере.
   179                                  ; Возвращаемое значение: преобразованное число
   180                                  func_reverse:
   181                                      ; rax = LEN / 2
   182 000001B9 4889F0                      mov rax, rsi               ; копируем количество байт в буфере
   183 000001BC 48D1E8                      shr rax, 1                 ; деление на 2
   184                                  
   185                                      ; rcx = i
   186 000001BF B900000000                  mov rcx, 0                 ; i = 0
   187                                  
   188                                  .loop:
   189                                      ; r8 = LEN - i - 1
   190 000001C4 4989F0                      mov r8, rsi
   191 000001C7 4929C8                      sub r8, rcx
   192 000001CA 49FFC8                      dec r8
   193                                  
   194 000001CD 448A140F                    mov r10b, [rdi + rcx]      ; копируем в регистр R10 байт buffer[i]
   195 000001D1 468A1C07                    mov r11b, [rdi + r8]       ; копируем в регистр R11 байт buffer[LEN - i - 1]
   196 000001D5 4D87D3                      xchg r10, r11              ; меняем значения регистров между собой
   197 000001D8 4488140F                    mov [rdi + rcx], r10b      ; возвращаем байт из R10 в память
   198 000001DC 46881C07                    mov [rdi + r8], r11b       ; возвращаем байт из R11 в память
   199                                  
   200 000001E0 48FFC1                      inc rcx                    ; i++
   201 000001E3 4839C1                      cmp rcx, rax               ; проверяем i
   202 000001E6 75DC                        jne .loop                  ; если i != LEN/2, то продолжаем цикл
   203                                  
   204 000001E8 C3                          ret
